# 해시

해시(hash)란 다양한 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑(mapping)한 값이다. 이를 이용해 특정한 배열의 인덱스나 위치나 위치를 입력하고자 하는 데이터의 값을 이용해 저장하거나 찾을 수 있다.

해시는 데이터를 다루는 기법 중에 하나로 검색과 저장이 아주 빠르게 진행된다. 아주 빠르게 진행될 수 있는 이유는 데이터를 검색할 때 사용할 key와 실제 데이터의 값(value)이 한 쌍으로 존재하고, key값이 배열의 인덱스로 변환되기 때문에 검색과 저장의 평균적인 시간 복잡도가 O(1)에 수렴하기 때문이다.

<br>

### 해시의 특징
- 무결성  
  해시는 특정한 데이터를 더 짧은 길이의 데이터로 변환하는 행위이다. 이때 상징 데이터는 원래의 데이터가 조금만 달라져도 확연하게 달라지는 특성을 가지고 있어 무결성을 지키는 데에 많은 도움을 준다.  
  예를 들어 'A'라는 문자열의 해시와 'B'라는 문자열의 해시는 고작 한 알파벳이 다를뿐이지만 해시 결과값은 완전히 다른 문자열이 나오게 된다.
- 보안성  
  해시는 기본적으로 복호화가 불가능하다. 입력 데이터 집합이 출력 데이터 집합을 포함하고 있어 특정한 출력 데이터를 토대로 입력 데이터를 찾을 수 없다. 즉, 동일한 출력값을 만들어낼 수 있는 입력값의 가짓수는 수학적으로 무한개이다. 실제로 해커가 쉽게 복호화를 할 수 없다는 점에서 강한 보안성을 가진다.
- 비둘기집 원리  
  대부분의 해시 알고리즘들은 항상 고정된 길이의 결과 문자열을 반환한다.  
  대표적인 해시 알고리즘은 MD5로 예를 들면, 128비트로 구성된 결과값, 즉 32자리의 16진수 값을 반환한다. 이 문자열의 길이는 변하지 않는다.  
  하지만 비둘기가 5마리일때 상자가 4개밖에 존재하지 않는다면 아무리 비둘기를 균등하게 분배해도 최소한 한 상자에는 2마리의 비둘기가 들어가게 된다. 이러한 원리를 비둘기집 원리라고 말한다.  
  이 원리에 따라 해시에서는 '서로 다른 입력 값의 해시 결과 값이 동일한 문제' 즉, 해시 충돌이 발생할 여지가 있다. 
- 해시레이트
  해시레이트는 연산 처리능력을 측정하는 단위로 해시 속도를 의미한다. 일반적으로 해시레이트가 높아져 연산량이 많아질 경우, 더 빠른 채굴이 이루어지기 때문에 채굴 난이도가 높아진다. 

<br>

### 해시 코드와 해시 함수, 해시 알고리즘

데이터의 key값을 배열의 인덱스인 정수로 변환하기 위해서는 일련의 과정이 필요하다. 예를 들어 데이터를 문자열로 받게 되었을 때 문자 한 글자 한 글자의 아스키 코드 값을 더하는 과정으로 문자열을 정수 값으로 변환할 수 있다. 

만약 hello 라는 문자열을 정수형 key 값으로 바꾼다면, h + e + l + l + o -> 104 +101 + 108 + 108 + 111 = 532라는 해시 코드로 변환할 수 있다.

이 예제 이외에도 여러 가지 방법으로 데이터를 해시코드로 바꾸기 위한 과정을 진행하게 되는데, 주어진 문제마다 적절한 해시 함수(해시 알고리즘)을 구현하는 것은 개발자의 역량에 달려있다.

<br>

- 해시 함수: 데이터를 효율적으로 관리하기 위해 임의의 길이의 데이터를 수학적 연산을 통해 고정된 길이의 데이터로 매핑하는 함수이다. 해시 함수에 의해 얻어지는 값을 해시 코드, 해시라고 한다.
- 해시 테이블: 키와 값을 매핑해둔 데이터 구조이다. 해시 함수로 얻은 해시를 키로 활용하여 index로 사용하고 해당 index에 데이터를 저장하여 효율적인 검색을 위해 사용된다.

<br>

### 해시 순서
1. 해당 원소의 해시 함수를 이용하여 해시값을 얻는다.
2. 해시값을 주소로 하는 위치에 원소를 저장한다.
3. 저장 후 검색 시에도 원소의 해시값으로 계산하여 해당 위치로 이동한다.

<br>

### 사용 용도
- 무결성 검사: 파일 다운로드 시 문제가 없는지 확인하는 용도로 다운로드하는 파일이 일부라도 변경된 경우 Checksum 값이 크게 달라진다.
- DB 비밀번호 저장
- 해시 테이블 사용

### 해시 코드를 사용해 해시 테이블(배열)에 저장하기

해시 코드로 나올 수 있는 숫자의 경우의 수는 아주 많다. 저장할 배열의 크기는 물리적 한계가 있고, 수많은 해시 코드들을 대처할 수 없다.

이런 경우 해시 코드를 배열의 크기로 나누고, 그 나머지를 인덱스로 사용하게 되면 0부터 (배열의 사이즈-1) 만큼의 숫자로 변환하여 사용할 수 있다.

예를 들어 해시 코드가 532이고 배열의 크기가 10인 경우 나머지가 2가 나오고, 이 나머지 값을 인덱스로 사용한다.

<br>

### 충돌 (collision)

하지만 위와 같이 인덱스를 한정된 인덱스로 바꾸게 된다면 다른 해시 코드라도 같은 인덱스가 나올 수 있다. (혹은 완전히 같은 해시 코드가 나올 수도 있다.) 즉, 입력된 결과값은 다르지만 같은 결과값이 출력될 경우를 말한다. 매우 희박한 확률이긴 하지만 충돌이 적은 해시 함수가 좋은 해시 함수이다.

이 충돌을 해결하는 방법으로는 분리 체인법, 선형 탐사, 2차 탐사, 이중해싱 등이 있다.

충돌로 인해 자바에서 hashCode()를 오버라이딩 할 때 단짝처럼 equals()도 오버라이딩 해야 한다. 별개의 객체가 우연히 해시코드가 똑같이 나오게 되더라도, equals()로 값의 동등성을 한번 더 확인 하는 과정을 거치게 되면 충돌을 방지할 수 있다.

<br>

### 충돌 해결 방법 
**분리 체인법**
> 충돌 시 연결 리스트에 추가하는 방식이다.

같은 인덱스를 가지는 데이터가 여러 개인 경우, 그 인덱스의 연결 리스트(Linked List)를 선언하고 각 데이터들을 이 리스트에 저장한다. 이 인덱스의 값을 저장, 검색하는 경우 먼저 인덱스의 접근하고 인덱스에 존재하는 링크드 리스트의 데이터들을 하나씩 조회한다. 그러므로 한 인덱스의 링크드 리스트의 사이즈가 크게 나오게 되면 해시 함수(해시 알고리즘)가 주어진 문제에 적절하지 않은 경우이므로 설계를 다시 해야 한다. 

연결 리스트로 인해 최악의 경우 수행 시간이 O(n)이 된다. 해시를 사용하는 이유는 O(1)이라는 장점으로 사용하는데, O(n)이 된다면 문제가 된다. 이러한 문제로 트리를 사용하면 시간 복잡도를 줄일 수 있다.

**Open Addressing**
>충돌 발생 시 해시 함수로 얻은 주소가 아닌 다른 주소 공간에 데이터를 저장한다.

Open Addressing은 충돌을 피하기 위한 다른 방법으로 key를 해시 테이블에 직접 저장한다. Open Addressing의 장점은 포인터를 사용하지 않아도 되어 구현이 간편하며, 검색도 미세하게 빨라진다. Open Addressing의 종류는 3가지가 있다.
  - 선형 프로빙(Linear Probing)  
  충돌이 발생할 경우 빈 slot이 나올 때까지 탐색 후, 빈 slot이 나오면 위치가 결정된다.   
  장단점: 구현은 매우 쉬우나 primary clustering 문제가 있다. primary clustering은 한번 충돌이 나면 집중적으로 충돌이 발생하는 것을 의미한다. 이로 인해 평균 검색 시간이 증가한다.
- 이차식 프로빙(Quadratic Probing)  
  2차 함수 꼴로 slot을 이동하면서 빈 slot을 찾는다.  
  장단점: 선형 프로빙에 비해 충돌이 적지만 secondary clustering이 발생한다. secondary clustering은 처음 충돌한 위치가 같다면 다음 충돌할 위치도 반복적으로 계속 충돌이 나게 된다는 의미이다.
- 이중 해시(Doubld Hashing)  
  충돌이 없을 때는 h1으로 위치를 탐색하고, 충돌이 있으면 h2 mod m 만큼 이동하면서 탐색한다.

<br>

### 언어별 해시 충돌 해결 방법

|언어|방식|
|---|---|
|C++|개별 체이닝|
|Java|개별 체이닝|
|Go|개별 체이닝|
|Ruby|오픈 어드레싱|
|Python|오픈 어드레싱|

<br>

### 해시 함수의 종류
**MD5 (Message-Digest algorithm 5)**

임의의 길이의 값을 입력받아서 128비트 길이의 해시값을 출력하는 알고리즘이다. MD5는 단방향 암호화이기 때문에 출력값에서 입력값을 복원하는 것은 불가능하다. 같은 입력값이면 항상 같은 출력값이 나오고 서로 다른 입력값에서 같은 출력값이 나올 확률은 극히 낮다.

흔히 패스워드 암호화에 많이 사용되는데, 패스워드를 MD5로 해시해서 나온 값을 저장해두는 것이다. 이렇게 하면 운영자나 데이터를 무단으로 뜯어 본 자도 이 값만 봐서는 본래의 값을 알 수 없다. 비밀번호를 정확하게 입력해야지 같은 해시값이 튀어나오므로, 본래의 키라는 것을 확인할 수는 있다. 하지만 MD5는 속도가 너무 빠르기 때문에 salt같은 수단을 붙이더라도 무차별 대입이나 사전 공격에 매우 취약하다. 비밀번호 해시 함수는 bcrypt나 scrypt 같은 비밀번호 해시 용도로 설계된 함수를 써야 한다.

*salt*

유래는 소금으로, 기본 양념인 소금처럼 원문에 가미하여 암호문을 다른 값으로 만드는 것이다. 이것이 가장 많이 쓰이는 곳은 일정한 결과값을 내며, 원문 복원이 불가능한 해시 함수이다. 이를 더 안전하게 만들기 위해 출력값과 다른 공간에 비밀스럽게 저장하는 후추(pepper)라고 한다.


**SHA (Secure Hash Algorithm)**

1993년 미국 NASA가 제작하고 미국 국립표준기술연구소(NIST)에서 표준으로 채택한 암호학적 해시 함수이다. 160비트의 값을 생성하는 해시 함수로, MD4가 발전한 형태이다. MD5보다 조금 느리지만 좀 더 안전한 것으로 알려져 있고, SHA에 입력하는 데이터는 512비트 크기의 블록이다.

SHA는 원본 값이 단 한 글자, 단 1비트만 바껴도 값이 천차만별로 바뀔 수 있다. 이러한 현상을 눈사태 효과라고 부른다.

<br>

#### 참고
[해시란 무엇인가 -티스토리](https://siyoon210.tistory.com/85)  
[해시함수 -해시넷 위키](http://wiki.hash.kr/index.php/%ED%95%B4%EC%8B%9C)   
[해시 -나무위키](https://namu.wiki/w/%ED%95%B4%EC%8B%9C)   
[암호처리기법 중 salt](https://namu.wiki/w/salt#s-3)  
[해시함수 종류 MD5](https://namu.wiki/w/MD5)  
[해시함수 종류 SHA](https://namu.wiki/w/SHA)  
[해시함수란 무엇인가](https://steemit.com/kr/@yahweh87/2)  
[해시와 해시 충돌 해결 방법 -티스토리](https://ryu-e.tistory.com/87)