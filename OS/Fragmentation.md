# 내부 단편화, 외부 단편화

### 메모리 관리 기법
메모리 관리 기법은 연속 메모리 관리와 불연속 메모리 관리로 나뉜다.  

### 연속 메모리 기법
- 프로그램 전체가 메모리에 연속적으로 할당되어야 하는 관리 기법
- 고정 분할 기법: 메모리가 고정된 파티션(길이)으로 분할 -> 필요한 용량보다 더 큰 메모리 받으면 메모리 낭비, **내부 단편화 발생**
- 동적 분할 기법: 파티션들이 동적 생성, 자신의 크기와 같은 파티션에 적재 -> 메모리 적재, 해제 반복 하면서 틈(낭비 메모리) 발생, **외부 단편화 발생**  

### 불연속 메모리 관리
프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법  
Page: 프로세스를 고정된 크기의 작은 블록들로 나눴을 때, 그 블록들을 페이지라 한다.  
Frame: 페이지 크기와 같은 주기억장치 메모리 블록  
Segment: 서로 다른 크기의 논리적 단위  

<br>

**메인 메모리(Main Memory, Physical Memory, 주기억장치)**  
CPU가 직접 접근할 수 있는 기억장치이다. 프로세스가 실행되려면 프로그램 코드를 메인 메모리에 적재해두어야 한다.   
**가상 메모리(Virtual Memory)**  
실제 메모리 크기와 상관 없이 메모리를 사용할 수 있도록 가상 메모리 주소를 사용하는 것을 뜻한다. 프로세스의 일부분만 메모리에 로드하고 나머지는 보조 기억 장치(가상 메모리 공간)에 로드한다.  
- MMU(가상 주소를 실제 메모리 주소로 변환해주는 장치)를 통해 논리 주소, 물리 주소를 나누어 사용하면서 CPU를 속인다.

<br>

### 내부 단편화 (Internal Fragmentation)
내부 단편화는 메모리를 할당할 때 **프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 공간이 낭비**되는 상황이다.   
<br>

![](https://velog.velcdn.com/images/jimeaning/post/55934257-d63d-437b-a956-6ca2497fcbd2/image.png)
![](https://velog.velcdn.com/images/jimeaning/post/ceae2118-fc0e-44f1-904e-8dbd412fa3bd/image.png)

그림과 같이 100MB의 메모리에 80MB 크기의 프로세스를 올리게 되면 20MB 만큼의 내부 단편화가 발생하게 된다. 즉, 적은 크기의 잔여 메모리가 발생해 해당 메모리를 사용할 수 없게 된다.  
<br>

### 외부 단편화 (External Fragmentation)
메모리가 할당되고 해제되는 작업이 반복적으로 일어날 때, 할당된 메모리와 메모리 사이에 중간중간 사용하지 않는 작은 메모리가 생긴다. 외부 단편화는 **남아 있는 총 메모리 공간이 요청한 메모리 공간보다 크지만 남아 있는 공간이 연속적이지 않아 발생하는 현상**이다  

![](https://velog.velcdn.com/images/jimeaning/post/845bdbc9-df26-400e-ace9-a94b66a46e10/image.png)

남아 있는 메모리 공간은 총 100MB(50MB+50MB)로 요청한 메모리 공간인 80MB 보다 크지만, 남아 있는 공간이 연속적이지 않아 Process C를 할당할 수 없게 된다. 따라서 남아 있는 메모리 공간이 낭비되는 문제가 발생한다.  
<br>

### 외부 단편화 해결방법 - 압축 (Compaction)
외부 단편화 문제를 해결하기 위해 압축 기법을 사용할 수 있다. 압축 기법은 주기억장치 내 분산되어 있는 **단편화된 공간들을 통합하여 하나의 커다란 빈 공간을 만드는 작업**이다.  

위 예시를 압축하면 다음과 같다.

![](https://velog.velcdn.com/images/jimeaning/post/5458984d-8d39-438b-93a9-15a2ddaba7d5/image.png)

흩어져 있던 공간을 연속된 공간, 즉 하나의 공간으로 만들면 기존에 할당할 수 없었던 프로세스를 할당할 수 있게 된다.  

![](https://velog.velcdn.com/images/jimeaning/post/9d6a7d4e-04af-48d4-9380-2d14aed9eafc/image.png)

<br>

### 페이징 (Paging)
프로세스를 일정한 크기의 페이지로 분할해서 메모리에 적재하는 방식이다.
- 페이지: 고정 사이즈의 가상 메모리 내 프로세스 조각
- 프레임: 페이지 크기와 같은 주기억장치의 메모리 조각

하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법이다.  

장점
- 논리 메모리는 물리 메모리에 저장될 때 연속되어 저장될 필요가 없고, 물리 메모리의 남는 프레임에 적절하게 배치되기 때문에 외부 단편화가 생기지 않는다.
  
단점
- 내부 단편화 문제가 발생할 수 있다. 페이지 단위를 작게하면 해결할 수 있지만 페이지 매핑 과정이 복잡해져 오히려 비효율적이다.

<br>

### 세그멘테이션 (Segmentation)
세그먼트는 가상 메모리를 서로 크기가 다른 논리적 단위로 분할한 것이다. 세그멘테이션은 프로세스를 물리적 단위인 페이지가 아닌, 논리적 단위인 세그먼트로 분할해서 메모리에 적재하는 방식이다.  
돼지를 도축할 때 페이징은 돼지를 같은 크기로 잘라서 보관하는 것이라면, 세그멘테이션은 부위별로 잘라서 보관한다고 이해하면 된다.  
이렇게 세그먼트는 의미가 같지 않은 논리적 내용을 기준으로 프로그램을 분할하기 때문에 크기가 같지 않다.  

장점
- 내부 단편화 문제가 해소된다.
- 보호와 공유 기능을 수행할 수 있다. 프로그램의 중요한 부분과 중요하지 않은 부분을 분리하여 저장할 수 있고, 같은 코드 영역은 한번에 저장할 수 있다.

단점
- 외부 단편화 문제가 생길 수 있다.

<br>


#### 참고
[내부 단편화, 외부 단편화란? | 외부단편화 해결 방법-티스토리](https://code-lab1.tistory.com/54)  
[CS 단편화, 세그멘테이션, 페이징](https://velog.io/@tlsdnxkr/CS-%EB%8B%A8%ED%8E%B8%ED%99%94-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98-%ED%8E%98%EC%9D%B4%EC%A7%95%EB%82%B4%EB%B6%80%EB%8B%A8%ED%8E%B8%ED%99%94-%EC%99%B8%EB%B6%80%EB%8B%A8%ED%8E%B8%ED%99%94)  
[페이징과 세그멘테이션-티스토리](https://steady-coding.tistory.com/524)