# 커널 수준 스레드와 사용자 수준 스레드

### 스레드
스레드는 **프로세스 내 작업 단위**이다.  
스레드는 하나가 될 수도 있고 여러 개가 될 수도 있다. 여러 개의 스레드가 동작하면 '멀티 스레드' 방식으로 동작하게 되는 것이다.  
스레드는 커널 수준 스레드와 사용자 수준의 스레드로 종류가 나뉜다.

<br>

### 커널 수준 스레드

![](https://velog.velcdn.com/images/jimeaning/post/16b6afc9-f847-4703-b242-f7358eecf1fb/image.png)

커널 수준 스레드는 커널 레벨에서 생성되는 스레드이다. 운영체제 시스템 내에서 생성되어 동작하는 스레드로 커널이 직접 관리한다.  
커널 수준에서는 프로세스가 주기억장치에 여러 개 적재되어 CPU 할당을 기다리며 동작한다.  
CPU에서 인터럽트 발생으로 현재 작업 중인 프로세스가 block 되고 다른 프로세스로 변경할 때, CPU 내 재배치 레지스터에 다음 번 실행할 프로세스 정보들로 교체하고 캐시를 비운다. 이것을 **컨텍스트 스위칭**이라고 한다.  
컨텍스트 스위칭이 일어날 때는 CPU가 일을 못한다. 그래서 자주 일어나면 성능 저하의 문제가 발생한다.  
하지만 커널이 직접 관리하므로 특정 스레드가 block 되어도 다른 스레드들은 독립적으로 일을 할 수 있다.

<br>

### 사용자 수준 스레드

![](https://velog.velcdn.com/images/jimeaning/post/f82ef865-d697-472a-9266-1e1825dc2154/image.png)

이 스레드는 스레드를 관리하는 라이브러리로 인해 사용자 단에서 생성 및 관리된다. 그래서 커널이 따로 관리하지 않고, 커널이 이 스레드에 대해 알지도 못한다. 즉 커널 레벨 밖에 있는 스레드이다.   

>스레드는 프로세스 단위인데 어떻게 운영체제 레벨인 커널 안이 아니라 밖에서 생성하여 이용할 수 있는가?   <br>=> 물리적으로 정말 커널 밖에 있는 것이 아니라, 전부 커널 내부에 있지만 **커널의 통제권 안에 있는지** 차이이다.  
커널에는 '커널 모드'와 '사용자 모드' 두 가지가 있고, 이때 '사용자 모드'에서 동작하는 스레드가 사용자 수준 스레드인 것이다.  
입출력 인터럽트가 발생하면 커널은 '사용자 모드'가 되어서 사용자 수준 스레드의 응답을 기다린다. 사용자 수준 스레드의 응답이 오면 다시 '커널 모드'로 변환되어 커널 스레드가 일처리를 하게 되는 것이다.

<br>

![](https://velog.velcdn.com/images/jimeaning/post/683f5db7-8228-410e-a4a1-54da4c861d48/image.png)

사용자 수준 스레드는 하나의 커널에 여러 스레드가 붙는다. 이는 사용자 레벨에서 스레드 전용 라이브러리를 이용해 여러 스레드를 생성한 것이다. (개발자가 자바에서 스레드 함수를 이용하면 이와 같이 된다.)  
이때 스레드는 운영체제 단의 기능을 하는 것이 아니라, 프로세스 내 커널과 관련 없는 기능들만을 수행하는 스레드이다. (개발자가 기능을 구현할 때 현재 기능 내에서 일처리를 하는 스레드를 만들 듯) 그래서 커널이랑은 관련도 없고 커널은 이런 스레드들이 있는지도 모른다.  
따라서 사용자 수준 스레드는 **컨텍스트 스위칭이 없고, 스레드 교체 등으로 인한 오버헤드 발생이 없다**.  
대신 인터럽트 당하면 커널 수준 스레드와 다르게 사용자 수준의 스레드들은 모두 함께 block 된다.

<br>

### 장단점 정리
**커널 수준 스레드**  
장점
- 사용자 수준 스레드보다 효율적이다. 커널 스레드를 쓰면 멀티 프로세서를 활용할 수 있기 때문이다. 
- 사용자 스레드는 CPU가 아무리 많아도 커널 모드의 스케줄이 되지 않으므로, 각 CPU에 효율적으로 스레드 배당할 수가 없다.

단점 
- context switching이 발생한다. 이 과정에서 프로세서 모드가 사용자 모드와 커널 모드 사이를 움직이기 때문에 많이 돌아다닐 수록 성능이 떨어지게 된다.
  

<br>

**사용자 수준 스레드**  
장점
- context switching이 없어서 커널 스레드보다 오버헤드가 적다 (스레드 전환 시 커널 스케줄러를 호출할 필요가 없기 때문)

단점  
- 프로세스 내의 한 스레드가 커널로 진입하는 순간, 나머지 스레드들도 전부 정지된다 (커널이 스레드의 존재를 알지 못하기 때문에)

<br>

#### 참고
[사용자 수준 스레드와 커널 수준 스레드의 차이 (매우 상세함)](https://helloinyong.tistory.com/293)  
[운영체제 사용자 수준 스레드 vs 커널 수준 스레드 차이](https://gyoogle.dev/blog/interview/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C.html)