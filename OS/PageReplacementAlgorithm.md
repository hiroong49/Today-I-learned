# 페이지 교체 알고리즘

가상 메모리 기법을 구현하는 방식 중 하나인 요구 페이징(Demanding Paging) 방식은 페이지 부재가 발생하게 된다. 페이지를 교체하는 작업은 오버헤드를 동반하기 때문에 가능하면 교체가 적게 일어나도록 하는 것이 좋다.  
<br>

### 🍏 페이지 교체
페이지 부재(page-fault)가 발생하면 요청된 페이지를 디스크에서 메모리로 읽어와야 한다. 이때 물리적 메모리에 빈 프레임이 존재하지 않을 수도 있다. 이 경우 **물리적 메모리에 올라와 있는 페이지 중 하나를 선택해서 디스크의 스왑 영역으로 보내야 한다**. 이 과정을 **페이지 교체**라고 한다.  
<br>

### 🍏 페이지 교체 알고리즘
**빈 프레임이 없을 경우 희생 당할 프레임(victim frame)을 고르는 알고리즘**이 **페이지 교체 알고리즘**이다.  
페이지 교체 알고리즘의 목표는 page-fault 발생 비율을 줄이는 것이다.  
<br>

#### ✔️ 종류
- **FIFO**: First In First Out
- **OPT**: Optimal, 앞으로 가장 오랫동안 사용하지 않을 페이지 교체
- **LRU**: Least *Recently* Used, 가장 오랫동안 사용하지 않은 페이지 교체 
- **LFU**: Least *Frequenty* Used, 참조 횟수가 가장 적은 페이지 교체
- **MFU**: Most Frequently Used, 참조 횟수가 가장 많은 페이지 교체
- **NUR**: Not Used Recently, 최근에 사용하지 않은 페이지 교체  

<br>

### FIFO (First In First Out) 알고리즘
- 가장 먼저 메모리에 올라 온 페이지를 가장 먼저 내보내는 알고리즘이다
- 구현이 간단하지만 성능은 좋지 않다
- 들어온 시간을 저장하거나 올라온 순서를 큐를 이용해 저장할 수 있다
- Belady's Anomaly 현상이 발생할 수 있다

![](https://velog.velcdn.com/images/jimeaning/post/9d35caf6-0335-4096-ae29-7182c7517a74/image.png)

**Belady's Anomaly**  
프레임의 개수가 많아져도 page-fault가 줄어들지 않고 늘어나는 현상이다.  
프레임의 개수가 많아지면 page-fault가 줄어야 하는게 일반적이지만 FIFO 알고리즘을 사용하면 그렇지 않을 수 있다.  
<br>

### OPT(Optimal) 알고리즘
- 가장 오랫동안 사용하지 않을 페이지를 교체하는 알고리즘이다
- 모든 페이지 교체 알고리즘 중 page-fault 발생이 가장 적다
- Belady's Anomaly 현상이 발생하지 않는다
- 프로세스가 앞으로 사용할 페이지를 미리 알아야 한다
- 실제로 구현하기는 거의 불가능하다
- 실제 사용보다는 비교 연구 목적으로 사용된다

![](https://velog.velcdn.com/images/jimeaning/post/e7ce2586-0019-4de5-96a5-b081f706933a/image.png)  

<br>

### LRU (Least Recently Used) 알고리즘
- 가장 오랫동안 사용하지 않은 페이지를 교체하는 알고리즘이다
- 가정: 가장 오랫동안 사용하지 않았던 데이터라면 앞으로도 사용할 확률이 적을 것이다 
 <- **시간의 지역성** (최근에 참조된 페이지가 가까운 미래에 다시 참조될 가능성이 높은 성질)을 고려함
- 최적 알고리즘과 비슷한 효과를 낼 수 있다
- 성능이 좋은 편이다
- 큐로 구현 가능하다. (사용한 데이터를 큐에서 제거하여 맨 위로 다시 올리고, 프레임이 모자라면 맨 아래에 있는 데이터를 삭제한다.)
- 많은 운영체제가 채택하고 있다
- 단점: 프로세스가 주기억장치에 접근할 때마다 참조된 페이지 시간을 기록해야 하므로 막대한 오버헤드가 발생한다.
- 카운터나 큐, 스택과 같은 별도의 하드웨어가 필요하다

![](https://velog.velcdn.com/images/jimeaning/post/63c264b5-8d68-42aa-af51-978a888915e7/image.png)  


**카운터**  
각 페이지별로 존재하는 논리적인 시계로, 해당 페이지가 사용될 때마다 0으로 초기화한 후 시간을 증가시켜 가장 오래된 페이지를 교체한다.  
<br>

### LFU (Least Frequently Used) 알고리즘
- 참조 횟수가 가장 적은 페이지를 교체하는 알고리즘이다
- 교체 대상이 여러 개라면 가장 오랫동안 사용하지 않은 페이지를 교체한다  
- LRU는 직전 참조된 시점만을 반영하지만, LFU는 참조 횟수를 통해 장기적 시간 규모에서의 참조 성향을 고려할 수 있다
- 단점: 가장 최근에 불러 온 페이지가 교체될 수 있다. 구현이 복잡하고 막대한 오버헤드가 발생할 수 있다.  


![](https://velog.velcdn.com/images/jimeaning/post/8fb9ad8e-dcee-4940-95d4-b746f83f6f9d/image.png)  
<br>

### MFU (Most Frequently Used) 알고리즘
- 참조 횟수가 가장 많은 페이지를 교체하는 알고리즘이다
- LFU와 반대이다
- 가정: 가장 많이 사용된 페이지가 앞으로는 사용되지 않을 것이다

![](https://velog.velcdn.com/images/jimeaning/post/8fb9ad8e-dcee-4940-95d4-b746f83f6f9d/image.png)  
<br>

### NUR (Not Recently Used) 알고리즘 / 클럭 알고리즘
- 최근에 사용하지 않은 페이지 교체 알고리즘이다 (LRU를 근사한 알고리즘)
- 교체되는 페이지의 참조 시점이 가장 오래되었다는 것을 보장하지는 않는다
- 적은 오버헤드로 적절한 성능을 낸다
- 동일 그룹 내에서 무작위로 선택한다
- 각 페이지마다 두 개의 비트(참조 비트와 변형 비트)가 사용된다
  - 참조 비트(Reference Bit): 페이지가 참조되지 않았을 때 0, 호출되었을 때 1 (모든 참조 비트를 주기적으로 0으로 변경한다)
  - 변형 비트(Modified Bit): 페이지 내용이 변경되지 않았을 때는 0, 변경되었을 때는 1이다.
  - 우선순위: 참조비트 > 변형비트

![](https://velog.velcdn.com/images/jimeaning/post/a2fa1102-235e-46f4-a304-9dacade4f551/image.png)
참조 비트를 순차적으로 조사하며 동작한다.
1. 프레임 내의 페이지가 참조될 때 하드웨어에 의해 1로 자동 세팅된다.
2. 한 바퀴 돌며 참조되지 않은 페이지의 참조 비트 값을 0으로 바꾼 후 지나간다.
3. 참조 비트가 0인 페이지를 방문하면 해당 페이지를 교체한다.

페이지가 참조되어 1이 되고, 한 바퀴 도는 동안 사용되지 않으면 0이 된다. 다시 한 바퀴를 도는 동안 사용되지 않는 페이지는 참조되지 않았으므로 교체 대상 페이지로 선정된다.  
클럭 알고리즘은 시계 바늘이 한 바퀴 도는 동안 걸리는 시간만큼 페이지를 메모리에 유지시켜 페이지 부재율을 줄이도록 설계되었다. 따라서 **2차 기회 알고리즘**이라고 부르기도 한다.

<br>



#### 참고
[페이지 교체 알고리즘-티스토리](https://code-lab1.tistory.com/60)  
[FIFO/LRU/LFU/MFU/NUR-티스토리](https://doh-an.tistory.com/28)  
[-티스토리](https://zangzangs.tistory.com/143)