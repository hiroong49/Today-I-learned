# 그래프

### 그래프의 구성 요소
- 정점 (Vertex/Node)
- 간선 (Edge)
- 가중치 (Cost)

<br>

### 그래프 구현 방법
#### 인접 리스트 (Adjacency List)

![](https://velog.velcdn.com/images/jimeaning/post/b30befd0-9a5f-47f0-b4d8-e56d62c17bf8/image.png)

인접 리스트는 정점에 연결되어 있는 정점들만 리스트로 나타내는 그래프 표현 방식이다.
- 필요한 만큼의 메모리만 사용하기 때문에 메모리 낭비가 없다.
- 정점들의 연결 정보를 확인하려 할 때는 간선의 개수만큼 탐색이 필요하다.  
  O(N) (N은 정점에 연결된 간선의 수)
- 이 과정이 행렬에 비해서는 오래 걸릴 수 있다.  
ex) 노드가 총 10000개인데 1번 노드에 9999개의 간선이 존재하는 경우 9999번 째 인접 정점을 확인하는데 9999번의 탐색이 필요하다

#### 인접 행렬 (Adjacency Matrix)

![](https://velog.velcdn.com/images/jimeaning/post/dc04c9f4-8599-46c1-93c9-03b171efc077/image.png)

인접 행렬은 2차원 배열로 그래프를 구현하는 방식이다. 간선이 존재하는 두 정점 칸은 1로, 없는 칸은 0으로 채워주고 만약 가중치가 다른 그래프라면 해당 가중치 값을 넣어준다.
- 2차원 배열 상에 그래프 정보가 모두 담겨 있기 때문에 간선의 존재 여부나 가중치를 알고 싶을 때 바로 참조할 수 있다.  
  O(1)
- 구현이 간단하다
- 하지만 N^N 크기의 2차원 배열을 사용하기 때문에 메모리가 필요 이상으로 많이 사용될 수 있다.  
  ex) 10000개의 정점으로 구성된 그래프에 간선이 5개만 존재할 경우
- 모든 간선 정보를 대입하는데 시간이 오래 걸린다.  
    O(N^N)

<br>

### 그래프 종류
#### 단방향 그래프
![](https://velog.velcdn.com/images/jimeaning/post/f23303b9-30c0-49fa-922b-0a1da733b0d1/image.png)

- 각 간선이 방향을 가진다.
- 에서 정점 v로 가는 간선 e가 있다면 이는 u->v를 의미할 뿐, v->u를 의미하는 것은 아니다.
- 간선의 방향대로만 이동할 수 있다.
#### 양방향 그래프
![](https://velog.velcdn.com/images/jimeaning/post/d2308cdf-a69e-4c84-ab1a-3115a5d7bfcb/image.png)

- 모든 간선이 양방향으로 연결된 그래프이다.
- 간선의 방향이 존재하지 않는다.
- 정점 u, v에 대해u->v라면 v->u이며, u->v가 불가능하다면 v->u 역시 불가능하다.
- 우리가 풀 문제는 대부분 양방향이다.
#### 가중치 그래프
![](https://velog.velcdn.com/images/jimeaning/post/a5aaf560-6c74-40b2-82e5-8f5fb89ec6bf/image.png)

- 간선에 가중치가 존재한다
- 정점 이동 시 해당 가중치만큼의 비용이 필요하다
#### 완전 그래프
![](https://velog.velcdn.com/images/jimeaning/post/532709dd-d360-491d-8f1f-7c7d24433073/image.png)

- 모든 정점 사이에 간선이 존재한다.
  
<br>

### 그래프 탐색
#### BFS
너비 우선 탐색이다.

정점을 기준으로 간선이 연결되어 있는 모든 정점들을 차례로 방문하고, 찾고자 하는 정점을 만날 때까지 사용한다.  
일반적으로 **Queue**를 사용하여 구현한다.

가중치가 같은 그래프 내에 **최단 거리** 문제에서 활용한다.

<br>

#### DFS
깊이 우선 탐색이다. 

정점을 기준으로 간선이 연결되어 있는 정점들 중 하나를 선택해 이동하고 다시 이동한 정점을 기준으로 인접 정점을 선택한다. 연결되어 있는 간선을 따라 찾고자 하는 정점을 만날 때까지 진행하고 찾지 못하면 다시 이전 정점으로 돌아와 반복한다.  
**재귀함수**나 **Stack**을 사용해 구현한다.

Connected Component 문제 유형에서 주로 활용한다. 속도가 더 빠르다.

<br>

### 인접 리스트와 인접 행렬
노드 A와 B가 연결되어 있다를 인접하다라고 한다.

**노드 간 연결 여부를 알려주는 2차원 배열**
- adjList[][]
- adjMatrix[][]

**위치를 방문했는지 알려주는 2차원 배열**
- visited[][]
  
<br>

인접 리스트의 특징
- 노드 2개가 주어진다
- 양방향 간선이라는 정보가 주어진다



#### 참고
[자료구조 그래프 -velog](https://velog.io/@nnnyeong/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%9E%98%ED%94%84-Graph)  
[그래프 -티스토리](https://sophia2730.tistory.com/entry/Data-Structure-Graph-%EA%B7%B8%EB%9E%98%ED%94%84)